### 【注：红色字体表示了可能优化的地方】

## To do list

- 能不能借用实验室的资源跑算法（gpu）
  - 用我们自己的图像集跑一下算法看结果
  - 增加图像的张数看效果
  
- **<font color='red'>【DDL：11月1日20:30】</font>**
  
  - 看论文[9] -> closed form matting
  - 最小二乘法 -> 求c
  - 看懂solve images函数
- 论文和代码的对应关系表格整理
  
- 整理我们的问题，制作ppt或word文档，发给黎叔看

- 实现算法的部分优化

- 制作中期答辩ppt

  

## 补充知识

### 梯度

- 图像梯度是指图像某像素在x和y两个方向上的变化率（与相邻像素比较），是一个二维向量，由2个分量组成，X轴的变化、Y轴的变化 。

- 我们即可以求出梯度向量的模和角度

  ![[公式]](https://www.zhihu.com/equation?tex=M_%7B2%7D%28x%2Cy%29%3D%5Csqrt%7Bg_%7Bx%7D%5E2+%2B+g_%7By%7D%5E2%7D)

  ![[公式]](https://www.zhihu.com/equation?tex=M_%7B1%7D%28x%2Cy%29%3D%7Cg_%7Bx%7D%7C+%2B+%7Cg_%7By%7D%7C+)

  ![[公式]](https://www.zhihu.com/equation?tex=M_%7B%5Cinfty%7D%28x%2Cy%29%3DMax%5C%7B%7Cg_%7Bx%7D%7C+%2C+%7Cg_%7By%7D%7C%5C%7D)

  ![[公式]](https://www.zhihu.com/equation?tex=%5Calpha+%28x%2Cy%29+%3D+tan%5E%7B-1%7D%5Cleft%5B+%5Cfrac%7Bg_%7By%7D%7D%7Bg_%7Bx%7D%7D+%5Cright%5D)

  模值也可以用 ![[公式]](https://www.zhihu.com/equation?tex=L_%7B1%7D) 或者![[公式]](https://www.zhihu.com/equation?tex=L_%7B%5Cinfty%7D) 范数来估计，在计算机实现上更为容易

  ![img](https://pic1.zhimg.com/80/v2-5b469c9adbf41cbd75f635b219d240fc_720w.jpg)

  梯度向量的几何意义如上图所示，模表示变化的剧烈程度，角度描述边缘的法线方向





## estimate_watermark.py

#### 估算水印梯度grad(W)

- ```python
  def estimate_watermark(foldername)
  ```

  - 估算水印的梯度 grad(W) = median(grad(J))
  - **返回值**
    - **gx**
    - **gy**
    - **gxlist**
    - **gylist**



#### 标准化图像

- ```python
  def PlotImage(image)
  ```

  - 将image转换为float类型，标准化到0-1之间



#### 二值化？

- ```python
  def image_threshold(image, threshold=0.5)
  ```
  - 像素值大于等于threshold*MAX的像素点置为1
  - <font color='red'>我们是否能改进这个函数？</font>



#### 裁剪水印

- ```python
  def crop_watermark(gradx, grady, threshold=0.4, boundary_size=2)
  ```

  - 输入的是grad(W)（水印的梯度gx，gy）
  - 计算梯度的模 W_mod = np.sqrt(np.square(gradx) + np.square(grady))
    - <font color='red'>如果图像很大，是否考虑用|gradx|+|grady|代题平方根以减少计算量？</font>
  - 调用***PlotImage***
  - 调用***image_threshold***
  - <font color='red'>裁剪效果不太好，保留了大块的无关区域，我们能否改进二值化算法？</font>
    - <img src="C:\Users\Doris Cullen\AppData\Roaming\Typora\typora-user-images\image-20201025152046702.png" alt="image-20201025152046702" style="zoom:50%;" />
  - **返回值**
    - **cropped_gx**
    - **cropped_gy**



#### 泊松重建 -> 粗略的水印（重建的是彩色图像？）

- ```python
  def poisson_reconstruct(gradx, grady, kernel_size=KERNEL_SIZE, num_iters=100, h=0.1, boundary_image=None, boundary_zero=True)
  ```

  - 从grad(W)重建出水印图像

  - <font color='red'>boundary_zero有啥用？可以考虑删掉？</font>

  - 首先计算laplacian，然后从一张噪声图逐步重建水印图像

  - ![image-20201025153156571](C:\Users\Doris Cullen\AppData\Roaming\Typora\typora-user-images\image-20201025153156571.png)

    - 图像中的边缘就是那些灰度值发生跳变的区域，拉普拉斯算子可以用二次微分正峰和负峰之间的0点确定边缘线的位置，因此可以突出图像中的孤立点、孤立线等。通梯度算子一样，拉普拉斯算子也会增强图像中的噪声，有时用拉普拉斯算子进行边缘检测时，可以将图像先进行平滑处理
      - 不过这里好像不是边缘检测？

  - 最后得到的loss还是挺大的，<font color='red'>有没有更好的方法求解泊松重建方程？或者增加迭代的轮数num_iters，修改参数h有没有效果？这里loss大对后面的影响大不大？</font>

    ```
    loss 99  =  42.12282793304221
    ```

  - <font color='red'>这里的error/loss值是否能用于评估图像的差别（去水印效果的好坏）</font>

  - **返回值**

    - **W_m**

    

- ```python
  def poisson_reconstruct2(gradx, grady, boundarysrc)
  ```

  - <font color='red'>也可以用它运行试一试</font>



#### 检测水印在图像中的位置

- ```python
  def watermark_detector(img, gx, gy, thresh_low=200, thresh_high=220, printval=False)
  ```

  - Wm = (np.average(np.sqrt(np.square(gx) + np.square(gy)), axis=2))
  - 用canny计算edgemap
  - 计算倒角距离
  - 找出了倒角距离最大的点
  - <font color='red'>倒角距离到底是个啥？这里是不是一种图像匹配算法？</font>
  - **返回值**
    - **im：画了矩形的图像**
    - **start：矩形左上角的坐标**
    - **end：矩形的长度**
      - <font color='red'>这个变量命名为end不合理，可以考虑修改其他代码（反正用的时候大多是start+end用的，直接加起来就挺好），或者把end变量名改为length</font>



## watermark_reconstruct.py

#### 裁剪图像

- ```python
  def get_cropped_images(foldername, num_images, start, end, shape)
  ```

  - **返回值**
    - **J：裁剪后的带水印图像，有4维，[index, , ,]**
    - **img_paths：图像的路径**



#### 一些疑问

- <font color='red'>**get a random subset of J** 干啥用的？代码好像没有用到？</font>
- <font color='red'>**Wm = W_m - W_m.min()**的作用？</font>



#### 估计α

- ```python
  def estimate_normalized_alpha(J, W_m, num_images=11, threshold=170, invert=False, adaptive=False, adaptive_threshold=21, c2=10)
  ```
  - np.stack
  - <font color='red'>iterpatch有什么用？</font>
  - 调用closed_form_matting.py中的函数



#### 估计blend factor

- ```python
  def estimate_blend_factor(J, W_m, alph, threshold=0.01*255)
  ```

  - 【参照论文中的3.2节：Matte and Blend Factor Initialization】
  - 论文中的依据：Jk = E(Wm) + c · αn · E[Ik]
  - 首先Jm = J - W_m
    - W_m与J维度不同，进行维度扩展再相减
  - E[I] = α * median(J, axis=0)
  - c = sum(梯度J * 梯度I) / sum(梯度I^2) / K
    - <font color='red'>论文中好像说用最小二乘法？</font>

